<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ubuntu上搭建dokuwiki</title>
    <url>/2020/01/13/ubuntu%E4%B8%8A%E6%90%AD%E5%BB%BAdokuwiki/</url>
    <content><![CDATA[<p><a href="https://www.dokuwiki.org/manual" target="_blank" rel="noopener">dokuwiki 官方使用手册</a></p>
<blockquote>
<p>搭建环境：</p>
<p>ubuntu（16.04）</p>
</blockquote>
<h3 id="安装web服务器和PHP"><a href="#安装web服务器和PHP" class="headerlink" title="安装web服务器和PHP"></a>安装web服务器和PHP</h3><pre><code class="bash">sudo apt-get install apache2 php7.0 php7.0-fpm php7.0-cli php-apcu php7.0-gd php7.0-xml php7.0-curl php7.0-json php7.0-mcrypt php7.0-cgi libapache2-mod-php7.0 php-patchwork-utf8</code></pre>
<h3 id="下载dokuwiki"><a href="#下载dokuwiki" class="headerlink" title="下载dokuwiki"></a>下载dokuwiki</h3><p><a href="https://www.dokuwiki.org/dokuwiki" target="_blank" rel="noopener">下载链接</a></p>
<p>解压得到的文件夹 dokuwiki 放到 /var/www/html/ 下，如：</p>
<pre><code class="bash">zyao@ubuntu:~$ ls /var/www/html/
dokuwiki  index.html
zyao@ubuntu:~$ ls /var/www/html/dokuwiki/
bin  conf  COPYING  data  doku.php  feed.php  inc  index.php  lib  README  vendor  VERSION
zyao@ubuntu:~$</code></pre>
<p>更改文件夹权限，如：</p>
<pre><code class="bash">cd /var/www/html/dokuwiki
sudo chown -R www-data:www-data data conf</code></pre>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>浏览器输入网址：<code>http://你的服务器IP/dokuwiki/install.php</code></p>
<h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><pre><code class="bash"># 1、
sudo mv data /home/zyao/.dokuwiki/ -f
# 2、追加一行内容：$conf[&#39;savedir&#39;] = &#39;/home/yourname/data/&#39;; 到conf/local.php
# 3、
mv conf /home/zyao/.dokuwiki/ -f
cd inc/
vi preload.php
mv bin /home/zyao/.dokuwiki/ -f</code></pre>
<h4 id="将目录移出根文档"><a href="#将目录移出根文档" class="headerlink" title="将目录移出根文档"></a>将目录移出根文档</h4><p>为了避免任何对上述目录的访问，最安全的方法就是把它们从 Web 服务所谓的“根文档”中移出来。</p>
<h5 id="data-目录"><a href="#data-目录" class="headerlink" title="data 目录"></a>data 目录</h5><ul>
<li>从根文档中移出 “data” 目录（和它所有的内容）</li>
<li>编辑 [[config:savedir]] 设置，使它指向 “data” 目录的新位置。</li>
</ul>
<p>例如，如果把 “data” 目录移动到 “/home/yourname/data”，添加以下这一行到 “conf/local.php”:</p>
<pre><code class="bash">  $conf[&#39;savedir&#39;] = &#39;/home/yourname/data/&#39;;</code></pre>
<h5 id="conf-目录"><a href="#conf-目录" class="headerlink" title="conf 目录"></a>conf 目录</h5><ul>
<li>从根文档中移出 “conf” 目录（和它所有的内容）</li>
<li>在 “inc” 目录内创建一个名为 preload.php 的文件,设置 “DOKU_CONF” 定义并使它指向 “conf” 目录的新地址。</li>
</ul>
<p>例如，如果把 “conf” 目录移动到 “/home/yourname/conf”,创建以下的 “inc/preload.php”文件：</p>
<p>&lt;code php inc/preload.php&gt;</p>
<pre><code class="php">&lt;?php

define(&#39;DOKU_CONF&#39;,&#39;/home/yourname/conf/&#39;);
&lt;/code&gt;</code></pre>
<h5 id="bin-目录"><a href="#bin-目录" class="headerlink" title="bin 目录"></a>bin 目录</h5><p>bin 目录包含了命令行工具。如果你没有 shell 可以访问你的服务器，你可以简单的删除该目录和它的内容。否则只要把它移出文档根即可。不需要更多的配置工作。</p>
<h5 id="inc-目录"><a href="#inc-目录" class="headerlink" title="inc 目录"></a>inc 目录</h5><p>从文档根中移出该目录，直到目前还没有简单的方法。但是因为它不包含任何的敏感数据，所以不值得努力尝试移出它了。</p>
<p><a href="https://www.dokuwiki.org/start?id=zh:security" target="_blank" rel="noopener">参考这里</a></p>
<p>参考博客：</p>
<p><a href="https://blog.csdn.net/wszll_Alex/article/details/80250249" target="_blank" rel="noopener">参考一</a>、<a href="https://linux.cn/article-8178-1.html" target="_blank" rel="noopener">参考二</a>、<a href="https://my.oschina.net/xiangxw/blog/36233" target="_blank" rel="noopener">参考三</a>、<a href="https://blog.csdn.net/boyStray/article/details/77113945" target="_blank" rel="noopener">dokuwiki升级</a></p>
<p><strong>效果展示：</strong><br><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/misc/2019-10-15_152955-dokuwiki-mainpage.png" alt=""></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>dokuwiki</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>上古神器 VIM</title>
    <url>/2020/01/12/%E4%B8%8A%E5%8F%A4%E7%A5%9E%E5%99%A8-VIM/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://vim.swaroopch.com/" target="_blank" rel="noopener">A Byte Of VIM</a><br><a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html" target="_blank" rel="noopener">按键功能总览</a><br><a href="https://www.cnblogs.com/yangjig/p/6014198.html" target="_blank" rel="noopener">参考博客一</a></p>
</blockquote>
<blockquote>
<p>不可错过的VIM视频教程：<a href="https://www.bilibili.com/video/av55498503" target="_blank" rel="noopener">一</a>、<a href="https://www.bilibili.com/video/av55664166" target="_blank" rel="noopener">二</a>、<a href="https://www.bilibili.com/video/av56020134" target="_blank" rel="noopener">三</a>、<a href="https://www.bilibili.com/video/av67091857" target="_blank" rel="noopener">四</a></p>
</blockquote>
<p>==约定：==</p>
<p><em>命令  Y  （大写 Y）  即输入：Shift + y</em></p>
<p><em>命令 c-v  即输入：Ctrl + v</em> </p>
<h1 id="VIM的各种模式"><a href="#VIM的各种模式" class="headerlink" title="VIM的各种模式"></a>VIM的各种模式</h1><ul>
<li>普通模式/命令模式（<strong>Normal Mode</strong>）</li>
<li>插入模式（<strong>Insert Mode</strong>）</li>
<li>覆盖模式（<strong>Replace Mode</strong>）</li>
<li>可视模式（<strong>Visual Mode</strong>）</li>
<li>可视行模式（<strong>Visual-Line Mode</strong>）</li>
<li>可视块模式（<strong>Visual-Block Mode</strong>）</li>
</ul>
<h3 id="各种模式之间的切换"><a href="#各种模式之间的切换" class="headerlink" title="各种模式之间的切换"></a>各种模式之间的切换</h3><ul>
<li>其他任何模式下都可以使用<code>Esc</code> 切换到 <strong>普通模式（Normal Mode）</strong></li>
<li>普通模式下：输入<code>R</code> 切换到 <strong>覆盖模式（Replace Mode）</strong>  （<code>r</code> 替换单个字符，例如：<code>ra</code>，将当前光标处的字符替换为a）</li>
<li>普通模式下：输入<code>v</code>, <code>V</code>，<code>c-v</code> 切换到 <strong>可视模式（Visual Mode）</strong><ul>
<li><code>v</code> 以<strong>字符</strong>为单位选择, 选中光标所在的字符, （结合<strong>上下左右</strong>可以选取更多）</li>
<li><code>V</code> 以<strong>行</strong>为单位选择, 选中光标所在行, （结合 <strong>上下</strong> 可以选取多行）</li>
<li><code>c-v</code> ，结合<strong>上下左右</strong>，可以选中一个矩阵块。</li>
</ul>
</li>
<li>普通模式下，切换到 <strong>插入模式（Insert Mode）</strong> 的方法：<ul>
<li><code>a</code> 在当前<strong>光标之后</strong>插入内容</li>
<li><code>A</code> 在当前<strong>行尾</strong>插入内容</li>
<li><code>i</code> 在当前<strong>光标之前</strong>插入内容</li>
<li><code>I</code> 在当前<strong>行首</strong>插入内容</li>
<li><code>o</code> <strong>向下</strong>插入新的一行，并进入插入模式</li>
<li><code>O</code> <strong>向上</strong>插入新的一行，并进入插入模式</li>
<li><code>cc</code> （双击c）删除当前行，并进入插入模式</li>
<li><code>C</code> <strong>删除</strong>从<strong>当前光标处</strong>到<strong>行尾</strong>的所有字符，并进入插入模式</li>
<li><code>s</code> 删除当前光标处的字符，并进入插入模式</li>
<li><code>S</code> 删除当前行，并进入插入模式 （感觉和<code>cc</code>没有区别）</li>
</ul>
</li>
</ul>
<pre><code class="markdown">+-----------+  i,I,a,A,o,O,cc,C,s,S +-----------+
| Normal    +----------&gt;------------+ Insert    |
| mode      |                       | mode      |
|           +----------&lt;------------+           |
+-+---+-----+        &lt;Esc&gt;          +-----------+
    |  |    \  \   
    |  |     \  \
    |  |      \  \
    |  |       \  \
v,  |  |        \  v  R, r
V   V  ^ &lt;Esc&gt;   \  \
c-v |  |    &lt;Esc&gt; ^  \
    |  |           \  \
    |  |            \  \
    |  |             \  \
+---+---+----+      +---+---+----+
| Visual     |      | Replace    |
| mode       |      | mode       |
+------------+      +------------+</code></pre>
<p>在<strong>普通模式</strong>下，我们输入的字符被当做命令去执行。在<strong>插入模式</strong>和<strong>覆盖模式</strong>下，我们输入的字符就是我们编辑的内容。在<strong>可视模式</strong>下，我们可以选中内容，选中后，可以继续输入命令，对选中的内容进行操作。</p>
<h3 id="VIM-按键功能总览图"><a href="#VIM-按键功能总览图" class="headerlink" title="VIM 按键功能总览图"></a>VIM 按键功能总览图</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/vi-vim-cheat-sheet.gif" alt="vi-vim-cheat-sheet"></p>
<p>注：注意区分各个按键的颜色。Operator和Motion的颜色不一样。</p>
<h1 id="Count-Operator-Count-Motion"><a href="#Count-Operator-Count-Motion" class="headerlink" title="{Count}Operator{Count}Motion"></a>{Count}Operator{Count}Motion</h1><h3 id="首先，看看我们有哪些Operators"><a href="#首先，看看我们有哪些Operators" class="headerlink" title="首先，看看我们有哪些Operators"></a>首先，看看我们有哪些Operators</h3><p>下面列出一些常用的，更多内容参考自<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#operator" target="_blank" rel="noopener">这里</a>。</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>delete</td>
</tr>
<tr>
<td>c</td>
<td>change</td>
</tr>
<tr>
<td>y</td>
<td>yank</td>
</tr>
<tr>
<td>=</td>
<td>indent</td>
</tr>
</tbody></table>
<h3 id="其次，看看我们有哪些Motions"><a href="#其次，看看我们有哪些Motions" class="headerlink" title="其次，看看我们有哪些Motions"></a>其次，看看我们有哪些Motions</h3><p>下面列出一些常用的，上（k）下（j）左（h）右（l），下一个单词（w/W），上一个单词（b/B）。还有很多各式各样的Motion，参考<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html" target="_blank" rel="noopener">这里</a>。</p>
<table>
<thead>
<tr>
<th>Motion</th>
<th>Function</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>end of line</td>
</tr>
<tr>
<td>0</td>
<td>first character of line</td>
</tr>
<tr>
<td>f{char}</td>
<td>当前行，向右查找字符，光标跳到该字符。（inclusive）</td>
</tr>
<tr>
<td>F{char}</td>
<td>当前行，向左查找字符，光标跳到该字符。（exclusive）</td>
</tr>
<tr>
<td>t{char}</td>
<td>当前行，向右查找字符，光标跳到该字符之前。（inclusive）</td>
</tr>
<tr>
<td>T{char}</td>
<td>当前行，向左查找字符，光标跳到该字符之后。（exclusive）</td>
</tr>
<tr>
<td>{number}gg</td>
<td>光标跳到第number行，如果不输入number，就是跳到首行</td>
</tr>
<tr>
<td>G</td>
<td>光标跳到文件尾行</td>
</tr>
<tr>
<td>H</td>
<td>跳转到当前屏幕的顶行</td>
</tr>
<tr>
<td>L</td>
<td>跳转到当前屏幕的底行</td>
</tr>
</tbody></table>
<p>注：</p>
<ol>
<li>光标在字符间移动，有两种模式：inclusive 和 exclusive 两种，区别是：是否包含最后一个字符。详见<a href="http://vimdoc.sourceforge.net/htmldoc/motion.html#inclusive" target="_blank" rel="noopener">这里</a></li>
</ol>
<h3 id="Operator-和-Motion-的组合：-Count-Operator-Count-Motion"><a href="#Operator-和-Motion-的组合：-Count-Operator-Count-Motion" class="headerlink" title="Operator 和 Motion 的组合：{Count}Operator{Count}Motion"></a>Operator 和 Motion 的组合：{Count}Operator{Count}Motion</h3><blockquote>
<p>The motion commands can be used after an operator command, to have the command operate on the text that was moved over.  That is the text between the cursor position before and after the motion.  Operators are generally used to delete or change text. If the motion includes a count and the operator also had a count before it, the two counts are multiplied. For example: “2d3w” deletes six words.</p>
<p>一个操作后面跟上一个动作，达到的效果是：<strong>在动作前后覆盖的内容上执行那个操作</strong>。</p>
</blockquote>
<p>这是一个非常强大的功能，可以自己尝试各种组合，打开属于自己的世界。<br>举一些例子：</p>
<ol>
<li><code>d2j</code> <strong>类似的命令我就经常使用到</strong> ，2j 光标会从当前行向下移动两行（光标扫过三行），d 表示删除。所以该命令会删除三行内容（包括当前行）。</li>
<li><code>y2w</code> 2w 光标会向后跳两个单词，y 表示复制。所以这个命令会复制从当前光标开始出的两个单词。</li>
<li><code>yfa</code> fa 会找到字符a，并将光标跳到该字符处。所以这个命令会从当前光标处一直复制到字符a。注意：实际我发现：<code>f</code> 只会在当前行查找。</li>
<li><code>gUw</code> gU 是一个operator，表示将字符换成大写，w 移动一个单词。所以这个命令会将当前单词换成大写（当然也是从当前光标处开始）。</li>
<li><code>cw</code> 删除当前单词（当然也是从当前光标处开始），并进入插入模式。</li>
<li><code>ci)</code> <strong>这个我就经常使用到</strong>， 删除 （） 里的内容并进入插入模式，类似的命令还有<code>ci&quot;</code> ：删除 双引号之间的内容并进入插入模式。需要说明的是：删除不是从光标处开始的，而是将（）内，或者 “” 内的内容都删除。更强大的是，括号里的内容跨行也可以。</li>
<li><code>ct\</code> <strong>这个我也经常使用到</strong>，删除从当前光标处开始直到字符 <code>\</code> 之前的内容，不能跨行。</li>
</ol>
<h3 id="查找-和-替换"><a href="#查找-和-替换" class="headerlink" title="查找 和 替换"></a>查找 和 替换</h3><p>查找：</p>
<table>
<thead>
<tr>
<th>Input</th>
<th>Func</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>向下查找字符串</td>
</tr>
<tr>
<td>?</td>
<td>向上查找字符串</td>
</tr>
<tr>
<td>*</td>
<td>向后查找当前光标所在单词</td>
</tr>
<tr>
<td>#</td>
<td>向前查找当前光标所在单词</td>
</tr>
<tr>
<td>n</td>
<td>跳到下一个匹配处</td>
</tr>
<tr>
<td>N</td>
<td>跳到上一个匹配处</td>
</tr>
</tbody></table>
<p>替换：</p>
<ul>
<li><code>:m,n s/oldstring/newstring/g</code> 替换字符串  （m,n 指定替换从m行到n行）</li>
<li><code>:.,$ s/oldstring/newstring/g</code></li>
<li><code>:% s/oldstring/newstring/g</code></li>
</ul>
<blockquote>
<p><code>.</code>表示当前行</p>
<p><code>%</code> 表示所有行</p>
<p><code>$</code> 表示文件最后</p>
<p><code>g</code> 表示全局替换，若无g则只替换每行找到的第一个字符串</p>
<p>如果替换字符串中有/，可以使用+ #作为分隔符</p>
</blockquote>
<h1 id="自定义快捷键实现小功能"><a href="#自定义快捷键实现小功能" class="headerlink" title="自定义快捷键实现小功能"></a>自定义快捷键实现小功能</h1><h3 id="LEADER-键"><a href="#LEADER-键" class="headerlink" title="LEADER 键"></a>LEADER 键</h3><p>LEADER键简单的说就是一个前缀键，默认是 <code>\</code>，在上上面的图中，可以看到：<code>\</code> 是 not used。我们可以将 LEADER键+其他的键，组合成自己想要的快捷键。我们也可以将LEADER键重新map成其他更好按的键位，比如空格。方法是：<code>let mapleader=&quot; &quot;</code> 。</p>
<h3 id="自定义分屏快捷键"><a href="#自定义分屏快捷键" class="headerlink" title="自定义分屏快捷键"></a>自定义分屏快捷键</h3><pre><code>&quot; split the screens to up (horizontal), 
&quot;                    down (horizontal), 
&quot;                    left (vertical), 
&quot;                    right (vertical).
map sj :set nosplitbelow&lt;CR&gt;:split&lt;CR&gt;:set splitbelow&lt;CR&gt;
map sk :set splitbelow&lt;CR&gt;:split&lt;CR&gt;
map sh :set nosplitright&lt;CR&gt;:vsplit&lt;CR&gt;:set splitright&lt;CR&gt;
map sl :set splitright&lt;CR&gt;:vsplit&lt;CR&gt;</code></pre><p>分屏后，可用通过 <code>:edit filename</code> 来打开新的文件。</p>
<p>我们还可以自己定义调整分屏大小的快捷键，如下：</p>
<pre><code>&quot; Resize splits with arrow keys
map &lt;up&gt; :res +2&lt;CR&gt;
map &lt;down&gt; :res -2&lt;CR&gt;
map &lt;left&gt; :vertical resize-2&lt;CR&gt;
map &lt;right&gt; :vertical resize+2&lt;CR&gt;</code></pre><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/split-screen.gif" alt="split-screen"></p>
<h3 id="自定义占位符"><a href="#自定义占位符" class="headerlink" title="自定义占位符"></a>自定义占位符</h3><pre><code class="vim">&quot; Press space twice to jump to the next &#39;&lt;++&gt;&#39; and edit it
noremap &lt;LEADER&gt;&lt;LEADER&gt; &lt;Esc&gt;/&lt;++&gt;&lt;CR&gt;:nohlsearch&lt;CR&gt;c4i</code></pre>
<p>这样设置之后，我在普通模式下，输入按下两次空格键后，会自动查找下一个’&lt;++&gt;’，删除它，并进入写入模式。</p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/place-holder.gif" alt="place-holder"></p>
<h1 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h1><p>我使用的vim插件管理器是vim-plug。安装和使用参考<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener">这里</a>。</p>
<h1 id="Little-Tips"><a href="#Little-Tips" class="headerlink" title="Little Tips"></a>Little Tips</h1><h3 id="norm"><a href="#norm" class="headerlink" title=":norm"></a>:norm</h3><p>可视行模式下，选中行后，可以输入<code>:normal</code> 或者 <code>:norm</code> 可以对每一行执行普通模式下的 commands 命令。</p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/visual-block-norm.gif" alt="visual-block-norm"></p>
<h3 id="set-filetype-xxx"><a href="#set-filetype-xxx" class="headerlink" title=":set filetype=xxx"></a>:set filetype=xxx</h3><p>vim 打开文件时，是根据文件的后缀来区分文件类型，显示出不同的语法高亮。但是有时文件名没有后缀，vim 识别不出文件类型，为了让语法高亮显示正确，我们需要手动设置文件类型。命令如：<code>:set filetype=make</code> <code>:set filetype=python</code> <code>:set filetype=vim</code> 等。</p>
<p>To see the list of language types available, check the <code>$VIMRUNTIME/syntax/</code> directory. </p>
<p>If you want the power of syntax highlighting for any Unix shell output, just pipe it to Vim. For example, <code>svn diff | vim -R -</code>.  Notice the dash in the end which tells Vim that it should read text from its standard input.</p>
<h3 id="map-与-noremap-的区别"><a href="#map-与-noremap-的区别" class="headerlink" title="map 与 noremap 的区别"></a>map 与 noremap 的区别</h3><p>map 是 vim 很强大的功能，可以让使用 vim 变的更顺手。除非自己明确的知道映射的结果，否则，没有特殊原因的情况下，应该使用 <code>noremap</code> ，胡乱使用 <code>map</code> 可能会有一些意想不到的结果。</p>
<pre><code class="vim">map b a
map c b</code></pre>
<p>在有上面两个映射的情况下，如果按下 c 键，vim 首先将 c 键映射为 b 键，然后 vim 会再去检查 b 键有没有被映射，此时，b 键又会被映射为 a  键。</p>
<pre><code class="vim">map b a
noremap c b</code></pre>
<p>使用 <code>noremap</code> 时，当按下 c 键会被映为 b 键，此时 vim 不会再去检查 b 键是否有映射，而是认为最终希望输入的就是 b 键。 </p>
<p><strong>其它：</strong> </p>
<ol>
<li><p>显示行号</p>
<blockquote>
<p>:set nu (不显示行号: set nonu)</p>
<p>需要总是显示行号时：将命令追加到~/.vim/vimrc文件中</p>
</blockquote>
</li>
<li><p>并列代开其它文件</p>
<blockquote>
<p>:vsp <filename></p>
</blockquote>
</li>
<li><p>并列打开的文件之间切换</p>
<blockquote>
<p>Ctrl + w</p>
</blockquote>
</li>
</ol>
<table>
<thead>
<tr>
<th>Input</th>
<th>Func</th>
</tr>
</thead>
<tbody><tr>
<td>{number}gg</td>
<td>光标跳到第number行，如果不输入number，就是跳到首行</td>
</tr>
<tr>
<td>G</td>
<td>光标跳到文件尾行</td>
</tr>
<tr>
<td>{n}dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>{n}yy</td>
<td>复制当前行</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存并退出</td>
</tr>
<tr>
<td>ZQ</td>
<td>不保存并退出</td>
</tr>
<tr>
<td>zz</td>
<td>将当前行显示在屏幕中间</td>
</tr>
</tbody></table>
<h1 id="遇到的问题记录"><a href="#遇到的问题记录" class="headerlink" title="遇到的问题记录"></a>遇到的问题记录</h1><ul>
<li>Visual Mode 下，白色字看不见的问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/visual-wt-1.jpg" alt="visual-wt-1"></p>
<p>Visual mode 选中后，就成下面的样子了：</p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/visual-wt-2.jpg" alt="visual-wt-2"></p>
<p>这是因为高亮颜色设置不对，<code>:highlight&lt;CR&gt;</code> 命令可查看所以高亮的颜色配置。</p>
<p>By the way，我的终端软件是Xshell6(Home)，也有可能和终端软件有关系。那我们就改了试试，看能不能生效。</p>
<p>改前的配置：</p>
<pre><code class="shell">Visual         xxx term=reverse ctermbg=7 guibg=LightGrey</code></pre>
<p>命令：</p>
<pre><code class="shell">:hi Visual term=reverse cterm=reverse ctermbg=none guibg=none</code></pre>
<p>改后的配置和效果：</p>
<pre><code class="shell">Visual         xxx term=reverse cterm=reverse guibg=none</code></pre>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/vi/visual-wt-3.jpg" alt="visual-wt-3"></p>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令记录</title>
    <url>/2019/12/25/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h3><p>Linux上的安装：</p>
<p>首先，安装Git需要的依赖包：sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</p>
<p>然后，sudo apt-get install git</p>
<h3 id="初次运行Git的配置"><a href="#初次运行Git的配置" class="headerlink" title="初次运行Git的配置"></a>初次运行Git的配置</h3><p>可以通过 <code>git config</code> 命令来修改配置。有 <code>--system</code>、<code>--global</code>、<code>--local</code> 三个参数。</p>
<p><code>git config --system</code> 读写的是/etc/gitconfig这个文件，系统上所有的用户共享的配置</p>
<p><code>git config --global</code> 用户宿主目录下的 ~/.gitconfig</p>
<p><code>git config --local</code>  本工程下的.git/config</p>
<p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p>
<pre><code class="shell"># 常用示例
git config --global user.name zhangyaaoo
git config --global user.email zhangyaaoo@gmail.com
git config --global core.editor vim

# 别名
git config --global alias.co checkout
git config --global alias.st status
git config --global alias.ci commit
git config --global alias.br branch
git config --global alias.unstage &#39;reset HEAD --&#39;

# 列出所有配置
git config --list

# 保存账号密码
git config --global credential.helper store</code></pre>
<h3 id="Git仓库初始化"><a href="#Git仓库初始化" class="headerlink" title="Git仓库初始化"></a>Git仓库初始化</h3><pre><code class="shell"># 在现有的目录中初始化仓库
git init

# 克隆已有的仓库
git clone https://github.com/zhangyaaoo/Hello-World
git clone https://github.com/zhangyaaoo/Hello-World my-hello-world</code></pre>
<h3 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h3><p>对于不想追踪管理的文件，可以将文件名写入 <code>.gitignore</code> 文件中。</p>
<p>对于已经被Git管理跟踪的文件，后来又想添加到 .gitignore 文件中，停止跟踪管理，则用命令</p>
<pre><code class="shell">git rm --cached filename</code></pre>
<p>从Git管理中删除。然后再将该文件名加入到 .gitignore 文件中，则可以停止跟踪管理该文件。</p>
<h3 id="添加修改到暂存区和本地提交"><a href="#添加修改到暂存区和本地提交" class="headerlink" title="添加修改到暂存区和本地提交"></a>添加修改到暂存区和本地提交</h3><pre><code class="shell">git add &lt;files&gt;
git commit -m &#39;log messages&#39;

# -a 选项只会暂存 修改 和 删除的 文件，对未跟踪的文件无影响
git commit -a -m &#39;made a change&#39;

# 查看 工作区的文件 相对于 暂存区的文件 的修改
git diff

# 查看 暂存区的文件 相对于 已提交的文件 的修改
git diff --staged</code></pre>
<h3 id="Git-log-amp-status"><a href="#Git-log-amp-status" class="headerlink" title="Git log  &amp; status"></a>Git log  &amp; status</h3><pre><code class="shell"># 查看log
git log
git log -p -2
git log --stat
git log --pretty=oneline
git log --pretty=format:&quot;%h - %an, %ar : %s&quot;
git log --pretty=format:&quot;%h %s&quot; --graph
git log --oneline --decorate

# 查看状态
git status 
git status -s</code></pre>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><pre><code class="shell"># 创建分支
git branch &lt;branch_name&gt;

# 切换分支
git checkout &lt;branch_name&gt;

## 创建分支并切换到该分支
git checkout -b &lt;branch_name&gt;
# 相当于：
git branch &lt;branch_name&gt;
git checkout &lt;branch_name&gt;

# 删除分支
git branch -d &lt;branch_name&gt;
git branch -D &lt;branch_name&gt; # 如果删除的分支有未合入当前分支的修改时，需要删除用 D

# 分支合并
git checkout &lt;branch_name_1&gt;
git merge &lt;branch_name_2&gt;

# 查看当前所有分支的列表
git branch
# 同时显示每个分支的最后一次提交
git branch -v

# --merged 与 --no-merged 这两个有用的选项可以过滤列表中已经合并或尚未合并到当前分支的分支
git branch --merged
git branch --no-merged</code></pre>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-MTD-Subsystem</title>
    <url>/2019/12/25/Linux-MTD-Subsystem/</url>
    <content><![CDATA[<p><a href="http://www.linux-mtd.infradead.org/doc/general.html" target="_blank" rel="noopener">资料来源</a></p>
<p>MTD(Memory Technology Devices)子系统提供了一个原始Flash设备的抽象层。对于不同类型的Flash设备，MTD子系统向上提供了相同的API。比如：NAND、OneNAND、NOR、AG-AND、ECC’d NOR 等等。</p>
<p>MTD子系统并不管理块设备，比如：MMC, eMMC, SD, CompactFlash 等等都属于块设备。这些块设备内部也有原始的Flash，另外芯片内部也有FTL(Flash Translation Layer)，让这些设备对外呈现出块设备的特性。</p>
<p>更多关于<a href="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_raw_vs_ftl" target="_blank" rel="noopener">Raw Flash 和 FTL Devices</a> 的对比。</p>
<p>注意：SSD, MMC, eMMC, RS-MMC, SD, mini-SD, micro-SD, USB flash drive, CompactFlash, MemoryStick, MemoryStick Micro, and other FTL devices are <strong>block devices</strong>, not raw flash devices.</p>
<p>块设备和MTD设备的区别：</p>
<table>
<thead>
<tr>
<th><strong>Block device</strong></th>
<th><strong>MTD device</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Consists of sectors</td>
<td>Consists of eraseblocks</td>
</tr>
<tr>
<td>Sectors are small (512, 1024 bytes)</td>
<td>Eraseblocks are larger (typically 128KiB)</td>
</tr>
<tr>
<td>Maintains 2 main operations: <strong>read sector</strong> and <strong>write sector</strong></td>
<td>Maintains 3 main operations: <strong>read from eraseblock</strong>, <strong>write to eraseblock</strong>, and <strong>erase eraseblock</strong></td>
</tr>
<tr>
<td>Bad sectors are re-mapped and hidden by hardware (at least in modern LBA hard drives); in case of FTL devices it is the responsibility of FTL to provide this</td>
<td>Bad eraseblocks are not hidden and should be dealt with in software</td>
</tr>
<tr>
<td>Sectors are devoid of the wear-out property (in FTL devices it is the responsibility of FTL to provide this)</td>
<td>Eraseblocks wear-out and become bad and unusable after about 103 (for MLC NAND) - 105 (NOR, SLC NAND) erase cycles</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MTD Subsystem</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 常用参数</title>
    <url>/2019/12/23/GCC-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>预处理阶段：（1.宏定义展开  2.头文件包含  3.条件编译）<br><strong>gcc hello.c -o hello.i -E</strong></p>
<p>编译阶段：（将c文件（.c）编译得到汇编文件（.s））<br><strong>gcc hello.i -o hello.s -S</strong></p>
<p>汇编阶段：（将汇编文件（.s）文件汇编得到二进制目标文件）<br><strong>gcc hello.s -o hello.o -c</strong></p>
<p>链接阶段：（链接得到二进制可执行文件）<br><strong>gcc hello.o -o hello.out</strong></p>
<p>可执行文件的执行：<br><strong>./hello.out</strong></p>
<ul>
<li><p>-E ：预编译处理</p>
</li>
<li><p>-S ：预处理-&gt;编译 生成汇编文件</p>
</li>
<li><p>-c ：预处理-&gt;编译-&gt;汇编 生成目标文件(但不链接)</p>
</li>
<li><p>-o ：指定输出的目标名称</p>
</li>
<li><p>-g ：添加调试信息</p>
</li>
<li><p>-I ：指定头文件搜索路径</p>
</li>
<li><p>-L ：指定链接库的路径</p>
</li>
<li><p>-l ：指定链接库的名称</p>
</li>
<li><p>-D ：编译时添加宏控制</p>
</li>
<li><p>-w ：不生成任何警告信息</p>
</li>
<li><p>-M : 获得目标文件的依赖关系</p>
</li>
<li><p>-MM : 获得目标文件的依赖关系，不包含系统头文件的依赖关系</p>
</li>
<li><p>-MT : 获得目标文件的依赖关系，并指定目标名</p>
</li>
<li><p>-Wall ：生成所有警告信息</p>
</li>
<li><p>-static ：此选项将禁止使用动态库，所以，编译出来的可执行文件一般都很大，运行时不需要加载动态链接库，就可以运行  </p>
</li>
<li><p>-share ：此选项将尽量使用动态库，所以生成文件比较小，但是运行的过程中需要加载动态链接库</p>
</li>
<li><p>-D ：<a href="http://blog.csdn.net/maopig/article/details/7230311" target="_blank" rel="noopener">Click for more</a><br>在Makefile文件里，我们会看到：<br>gcc -D MACRONAME=MACRODEF 或者 gcc -D MACRONAME<br>这样就定义了预处理宏，编译的时候可选代码就会被编译进去了。<br>对于GCC编译器，有如下选项：[-D macro=string]或者[–define-macro macro=string]<br>-D macro=string，等价于在头文件中定义：#define macro string<br>如：-D TRUE=true，等价于：#define TRUE true<br>-D macro，等价于：#define macro 1，实际上也达到了定义：#define macro的目的。<br>如：-D LINUX，等价于：#define LINUX 1（与#define LINUX作用类似）。<br>​</p>
</li>
<li><p>-On ：指定优化级别(其中 n 的取值可以为：0、1、2、3 。各个优化级别的区别参考<a href="http://blog.csdn.net/qq_31108501/article/details/51842166" target="_blank" rel="noopener">这里</a>)</p>
<p>在实际的运用过程中，发现对于CPU密集型的程序来说，增加优化级别能够大幅缩短执行时间。比如下面给升级镜像增加OOB区域的数据（制作烧录镜像）。</p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/make/diff-Ox.png" alt="diff-Ox"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC总线</title>
    <url>/2019/12/21/IIC%E6%80%BB%E7%BA%BF/</url>
    <content><![CDATA[<p><a href="http://www.ti.com/lit/an/slva704/slva704.pdf" target="_blank" rel="noopener">资料来源</a></p>
<h2 id="IIC总线上的三种信号类型"><a href="#IIC总线上的三种信号类型" class="headerlink" title="IIC总线上的三种信号类型"></a>IIC总线上的三种信号类型</h2><h3 id="开始和结束信号"><a href="#开始和结束信号" class="headerlink" title="开始和结束信号"></a>开始和结束信号</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-start-stop.png" alt="iic-start-stop"></p>
<h3 id="应答信号"><a href="#应答信号" class="headerlink" title="应答信号"></a>应答信号</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-ack.png" alt="iic-ack"></p>
<h3 id="一个字节的传输"><a href="#一个字节的传输" class="headerlink" title="一个字节的传输"></a>一个字节的传输</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-single-byte-transfer.jpg" alt="iic-single-byte-transfer"></p>
<blockquote>
<p>看着这样的时序图的时候，有一个暗线：时间。既然叫“时序图”，那么时间是隐藏在图中的很重要变量，</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-single-byte-transfer-t.png" alt="iic-single-byte-transfer-t"></p>
<p><strong>所以从左到右，随着时间的流逝，首先发送的数据是MSB，最后发送的是LSB。</strong></p>
<h2 id="IIC协议内容"><a href="#IIC协议内容" class="headerlink" title="IIC协议内容"></a>IIC协议内容</h2><p>首先区分下面几个名词</p>
<ul>
<li>MASTER (主机)</li>
<li>SLAVE (从机)</li>
<li>TRANSMITTER (发送方)</li>
<li>RECEIVER (接收方)</li>
</ul>
<p>==协议要求：==</p>
<ol>
<li>开始和结束信号只能由主机发送。</li>
<li>应答信号由数据接收方发送，数据接收方可以是主机，也可以是从机。</li>
<li>SCL上的时钟信号始终都是由主机发送的。</li>
<li>在传输数据时：SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化。在SCL为高电平期间改变SDA上的数据将被视为开始或者结束信号。</li>
<li>IIC传输的字节必须是8位。每个字节传输后都要跟随一个应答信号。对每次数据传输的字节数没有严格限制。</li>
<li>先发送高位字节(MSB)。</li>
</ol>
<h2 id="SDA-SCL线如何输出高低电平"><a href="#SDA-SCL线如何输出高低电平" class="headerlink" title="SDA/SCL线如何输出高低电平"></a>SDA/SCL线如何输出高低电平</h2><h3 id="拉低"><a href="#拉低" class="headerlink" title="拉低"></a>拉低</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-pulling-down.jpg" alt="iic-pulling-down"></p>
<p><strong>当主机或从机想输出一个低电平，通过使FET导通，将引脚线接地，输出一个低电平。</strong></p>
<p>The logic wanting to transmit a low will activate the pull-down FET, which will provide a short to ground, pulling the line low.</p>
<h3 id="拉高"><a href="#拉高" class="headerlink" title="拉高"></a>拉高</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-release-high.jpg" alt="iic-release-high"></p>
<p><strong>当主机或从机想输出一个高电平(只能通过释放总线)，通过使FET截止，将引脚线悬空，由于上拉电阻的作用，引脚将输出一个高电平。</strong></p>
<p>When the slave or master wishes to transmit a logic high, it may only release the bus by turning off the pull-down FET. This leaves the bus floating, and the pull-up resistor will pull the voltage up to the voltage rail, which will be interpreted as a high. The figure shows the flow of current through the pull-up resistor, which pulls the bus high.</p>
<h3 id="SDA、SCL线上的上拉电阻"><a href="#SDA、SCL线上的上拉电阻" class="headerlink" title="SDA、SCL线上的上拉电阻"></a>SDA、SCL线上的上拉电阻</h3><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-pin-internal.jpg" alt="iic-pin-internal"></p>
<p>最近，一些工程师在处理IIC单片机接口的工作问题时，对外部接上拉电阻的做法感到疑惑。由于单片机内部已经设置了上拉电阻，对于外部是否还需要接上拉的情况业界一直存在争议。针对I2C是否有必要接上拉的问题，就让牛人来为我们进行深入解读。</p>
<p>由于一些单片机型号内部就设置了上拉电阻，因此有些上拉能力够了，是可以不加上拉电阻，有些不够，那就必须在外部加上拉电阻。在这种情况下，主要是取决于工程师所使用的单片机是否有标准的IIC标准接口。如果单片机使用了标准的IIC接口，那么接口在使能时引脚将进入漏极开路模式，可以省去外部接入的上拉电阻。但如果是使用单片机的引脚模拟IIC协议的话，就需要结合单片机引脚是否支持漏极开路模式或者上拉模式来进行判断，这种情况下一般是需要接入一个外部的上拉电阻的。</p>
<p>除此之外，在IIC接口接入上拉电阻，也可以起到保护作用。由于I2C接口在工作时主要负责的是对高低电平检测的作用，一旦没有了上拉电阻的保护而直接接电源，出现器件拉低时整个系统就非常危险。根据I2C总线规范，总线空闲时两根线都必须为高。根据IIC总线规范的要求，总线空闲时两根线都必须为高。但由于IIC接口采用Open Drain机制，本身只能输出低电平而无法主动输出高电平，所以只能通过外部上拉电阻RP将信号线拉至高电平。因此I2C总线上的上拉电阻是必须要接入的。</p>
<p>结语</p>
<p>工程师需要依据IIC接口的具体情况，判断是否有必要在外部单独接入一个上拉电阻。如果没有使用标准的I2C接口，为了系统的稳定和安全，在外部进行上拉电阻的接入就是必须的工作了。<a href="https://www.dianyuan.com/article/30297.html" target="_blank" rel="noopener">摘抄自这里</a></p>
<h2 id="一次完整的传输"><a href="#一次完整的传输" class="headerlink" title="一次完整的传输"></a>一次完整的传输</h2><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-data-transfer.jpg" alt="iic-data-transfer"><br>主机发送开始信号后，随后发送7-bit的从机地址，第8位发送读写位，读写位标志着：主机接下来是写数据到从设备，还是从从设备读数据。</p>
<p>然后，<strong>主机释放SDA线 (释放以后，由于上拉电阻的作用，SDA线上的电平状态被上拉电阻拉高)，等待从设备的应答</strong>。每一个字节的数据传送完成后都会有一个位的应答。</p>
<p>应答时：从机将SDA线上的电平拉低，并在第9个时钟周期SCL为高电平时一直保持拉低状态，保证主机能够正常读取从机的应答。</p>
<p><strong>发送开始信号后，可以不发送结束信号，再一次发送开始信号。</strong></p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-writemode-7-addr.jpg" alt="iic-writemode-7-addr"></p>
<p><strong>主机读写从机寄存器中的数值：</strong><br><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-single-byte-write.jpg" alt="iic-single-byte-write"></p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-single-byte-read.jpg" alt="iic-single-byte-read"><br>==注意==：主机接收器在接收到最后一个字节后，不会发出ACK信号。于是从机释放SDA线，以允许主机发出P信号结束传输. </p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-read-register.jpg" alt="iic-read-register"></p>
<hr>
<p>为什么向从机寄存器写数据时，不需要重新发送开始信号，而从从机寄存器读数据时，需要重新发送开始信号？</p>
<p>在发送开始信号后，主机需要发送从机地址和读写位，可以认为读写位规定了这次开始传输的数据流向，写：表示数据由主机给出，从机接收数据；读：表示数据由从机给出，主机接收数据。</p>
<p>当向从机寄存器写数据时，数据的流向一直是从主机流向从机；</p>
<p>当从从机寄存器读数据时，我们首先需要向从机给出寄存器地址，然后从机给主机发送寄存器中的值，数据的流向所有改变，所以我们需要在向从机写入寄存器地址后，重新发送开始信号，此时读写位为1，指明接下来从机发送数据给主机。</p>
<hr>
<h2 id="总线的状态"><a href="#总线的状态" class="headerlink" title="总线的状态"></a>总线的状态</h2><h3 id="空闲状态"><a href="#空闲状态" class="headerlink" title="空闲状态"></a>空闲状态</h3><p>SDA、SCL都为高电平，开始信号发出前，结束信号发出后。</p>
<h3 id="忙碌状态"><a href="#忙碌状态" class="headerlink" title="忙碌状态"></a>忙碌状态</h3><p>开始信号发出后，结束信号发出前都视为忙碌状态。</p>
<h2 id="实际波形分析"><a href="#实际波形分析" class="headerlink" title="实际波形分析"></a>实际波形分析</h2><p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-real-wave.jpg" alt="iic-real-wave"><strong>上图是一个实际的IIC传输的波形.(黄色:SCL 绿色:SDA)</strong></p>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-real-wave-one-byte.jpg" alt="iic-real-wave-one-byte"><br><strong>实际的波形和上面理论分析的波形有所不同，不同的地方是</strong>: SDA线上的数据是在时钟负跳变时几乎马上输出的，如序号2和3标记的地方。但是这个符合：SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化。</p>
<ul>
<li>数据传输起始信号,(序号1标记的地方): 时钟为高时,数据线上电平的负跳变.</li>
<li>数据传输过程中,时钟为高时,数据线上保持电平稳定. 如序号4和5标记的地方.</li>
<li>起始位(6)，地址传输(7)，读写位(8)，应答(9)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyaaoo/ImageBed/master/iic/iic-real-wave-parse.jpg" alt="iic-real-wave-parse"></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Hexo &amp; Github 搭建自己的博客</title>
    <url>/2019/12/18/%E5%9F%BA%E4%BA%8E-Hexo-Github-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Install-Node-js-amp-Git-amp-npm"><a href="#Install-Node-js-amp-Git-amp-npm" class="headerlink" title="Install Node.js &amp; Git &amp; npm"></a>Install Node.js &amp; Git &amp; npm</h1><pre><code class="shell">sudo apt install nodejs git npm
# 安装版本查看
node --version
git --version
npm --version
</code></pre>
<h1 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h1><pre><code class="shell">sudo npm install hexo-cli -g
# 查看安装的版本
hexo --version</code></pre>
<h1 id="Starting…"><a href="#Starting…" class="headerlink" title="Starting…"></a>Starting…</h1><h3 id="初始化博客的工作目录"><a href="#初始化博客的工作目录" class="headerlink" title="初始化博客的工作目录"></a>初始化博客的工作目录</h3><pre><code class="shell">hexo init Blog
# 本地检验
cd Blog; hexo s
# 浏览器输入 localhost:4000 测试 Ctrl+C 结束</code></pre>
<h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><pre><code class="shell"># 尝试新建自己的第一篇文章
hexo n &quot;基于-Hexo-GitHub-搭建自己的博客&quot;
# 编辑 source/_posts/基于-Hexo-GitHub-搭建自己的博客.md
hexo clean
hexo g
hexo s
# 浏览器输入 localhost:4000 本地测试， Ctrl+C 结束</code></pre>
<h3 id="部署自己博客到GitHub"><a href="#部署自己博客到GitHub" class="headerlink" title="部署自己博客到GitHub"></a>部署自己博客到GitHub</h3><ul>
<li><p><code>sudo npm install --save hexo-deployer-git</code> 安装hexo部署功能的插件</p>
</li>
<li><p>创建 yourname.github.io 的仓库</p>
</li>
<li><p>修改配置文件 <code>_config.yml</code> </p>
<pre><code class="shell"># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repo: https://github.com/zhangyaaoo/zhangyaaoo.github.io.git
  branch: master</code></pre>
</li>
<li><p><code>hexo d</code> 部署到GitHub</p>
</li>
<li><p><code>zhangyaaoo.github.io</code> 访问测试</p>
</li>
</ul>
<h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><ul>
<li><p>下载主题 <code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code> </p>
</li>
<li><p>修改博客配置文件 <code>_config.yml</code> </p>
<pre><code class="shell"># Extensions
## Plugins: https://hexo.io/plugins/
## Themes: https://hexo.io/themes/
theme: yilia</code></pre>
</li>
</ul>
<ul>
<li><p><code>hexo clean</code> </p>
</li>
<li><p><code>hexo g</code> </p>
</li>
<li><p><code>hexo s</code> 浏览器输入 localhost:4000 本地测试， Ctrl+C 结束</p>
</li>
<li><p><code>hexo d</code> 部署到GitHub </p>
</li>
</ul>
<h1 id="多地点管理博客"><a href="#多地点管理博客" class="headerlink" title="多地点管理博客"></a>多地点管理博客</h1><h3 id="旧电脑上"><a href="#旧电脑上" class="headerlink" title="旧电脑上"></a>旧电脑上</h3><ul>
<li><p>首先在仓库 <strong>yourname.github.io</strong> 上新建一个分支用来存放博客的源文件。 <code>hexo d</code> 命令提交到master分支上的是站点的静态文件，在新的分支上，删除 <code>.git</code> 以外的所有文件夹。</p>
</li>
<li><p>将已有的Blog文件夹中的如下文件，拷贝到新的分支上，并提交至该分支。</p>
<pre><code class="shell">
├── _config.yml
├── package.json
├── scaffolds
├── source
└── themes
    ├── clean-blog
    │   └── _config_clean-blog.yml
    └── yilia
        └── _config_yilia.yml
# 为了不提交主题目录下的多余的文件
# 我这里并没有改动主题里的源文件，只改动了_config.yml这个文件
# 所以我只提交了yml配置文件。</code></pre>
</li>
</ul>
<h3 id="新电脑上"><a href="#新电脑上" class="headerlink" title="新电脑上"></a>新电脑上</h3><ul>
<li><p>克隆仓库 <strong>yourname.github.io</strong> 的分支上的内容到本地。当然新的电脑上，Node.js &amp; Git &amp; npm &amp; hexo 的安装不可少</p>
</li>
<li><p>克隆主题的源文件到对应的目录下</p>
</li>
<li><p>执行下面的命令：</p>
<pre><code class="shell">npm install
npm install hexo-deployer-git --save
npm install hexo-server --save
hexo clean &amp;&amp; hexo g &amp;&amp; hexo s # 本地访问测试</code></pre>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/18/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
